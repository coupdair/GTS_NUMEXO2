#include "align.h"
#include "xmmregs_i.h"
#include "debug.h"

#define DBG DBG_TRIGGER

int muxClkSyncSet(unsigned int val) {
  return XMMRegs_DataPath_MuxClkSync_Set(&XMMRegsDriver, val);
}

int checkCompatibilityTriggerCoreGtsType(int GTStype) {
  int status = XST_SUCCESS;
  int trigger_type;
  
  trigger_type = XMMRegs_Trigger_CoreType_Get(&XMMRegsDriver);
  
  DBG(DBLD, "trigger_type = %d\n", trigger_type);
  DBG(DBLD, "GTStype = %d\n", GTStype);
  
  switch (trigger_type) {
    case TRIGGER_CORE_IS_ROOT :
      switch (GTStype) {
        case ROOT :
          break;
        case FANIN_FANOUT :
          DBG(DBLW, "WARNING : you use the root trigger core with a fanin-fanout node\n");
          DBG(DBLW, "It is probably an error, except if you know what you are doing\n");
          DBG(DBLW, "It will not be reported as an error\n");
          break;
        default :
          DBG(DBLE, "ERROR : trigger core is ROOT, GTS type is LEAF\n");
          status = XST_FAILURE;
          break; 
      }
      break;
    case TRIGGER_CORE_IS_LEAF :
      switch (GTStype) {
        case LEAVE :
          break;
        case FANIN_FANOUT :
          DBG(DBLE, "ERROR : you use the leaf trigger core with a fanin-fanout node\n");
          status = XST_FAILURE;
          break;
        default :
          DBG(DBLE, "ERROR : trigger core is LEAF, GTS type is ROOT\n");
          status = XST_FAILURE;
          break;
      }
      break;
    case TRIGGER_CORE_IS_FANIN_FANOUT :
      switch (GTStype) {
        case LEAVE :
          DBG(DBLE, "ERROR : trigger core is FANIN_FANOUT, GTS type is LEAF\n");
          status = XST_FAILURE;
          break;
        case FANIN_FANOUT :
          break;
        default :
          DBG(DBLE, "ERROR : trigger core is FANIN_FANOUT, GTS type is ROOT\n");
          status = XST_FAILURE;
          break;
      }
      break;
    default :
      DBG(DBLW, "STRANGE : trigger core is neither root nor leaf nor faninfanout\n");
      status = XST_FAILURE;
      break;  
  }
  
  return status;
}

int triggerPathSet(int GTStype)
{
  int status = XST_SUCCESS;
  
  status |= XMMRegs_DataPath_UseSync_UnSet(&XMMRegsDriver);
  status |= XMMRegs_DataPath_AllRxmux_Set(&XMMRegsDriver, 1); // NUMEXO2
  status |= XMMRegs_DataPath_AllTxmux_Set(&XMMRegsDriver, 5); // NUMEXO2
   
  switch (GTStype) {
    case ROOT :
      break;
    case FANIN_FANOUT :
      break;
    case LEAVE :
      break;
    default :
      DBG(DBLE, "ERROR : out of range error on GTStype values in function triggerPathSet\n");
      status |= XST_FAILURE;
      break; 
  }
  
  return status;
}

/* launches the leave trigger core in test-loopback mode 
Applies to a leave GTS */
int leaveTestLoopback(void) {
  return XMMRegs_Trigger_Leave_TestLoopback_Set(&XMMRegsDriver); 
}

/* launches the leave trigger core in loopback mode 
Applies to a leave GTS */
int leaveTest(void) {
  return XMMRegs_Trigger_Leave_Test_Set(&XMMRegsDriver); 
}

int leaveCarrierRequest(void) {
  return XMMRegs_Trigger_Leave_CarrierRequest_Set(&XMMRegsDriver);
}

/* Applies to a root GTS */
int rootLoopback(void) {
  return XMMRegs_Trigger_Root_Loopback_Set(&XMMRegsDriver);
}

int rootAuroraLoopback(void) {
  return XMMRegs_Trigger_Root_AuroraLoopback_Set(&XMMRegsDriver);
}

int daqStart(void) {
  return XMMRegs_Trigger_Daq_Start(&XMMRegsDriver);
}

int daqStop(void) {
  return XMMRegs_Trigger_Daq_Stop(&XMMRegsDriver);
}

int syncPeriodSet(int period_mask) {
  return XMMRegs_Trigger_PeriodMask_Set(&XMMRegsDriver, period_mask);
}

int triggerCoreSet(int GTStype) {
  int status = XST_SUCCESS;
   
  switch (GTStype) {
    case ROOT :
      break;
    case FANIN_FANOUT :
      break;
    case LEAVE :
      if ( XMMRegs_AlignMode_Read(&XMMRegsDriver) == CARRIER_INCLUDED ) {
        DBG(DBLI, "LLP_Carrier handles the trigger requests (test mode OFF)\n");
        status |= XMMRegs_Trigger_Leave_CarrierRequest_Set(&XMMRegsDriver);
      }
      else {
        DBG(DBLI, "Trigger requests are generated by the GTS (test mode ON)\n");
//        status |= XMMRegs_Trigger_Leave_Test_Set(&XMMRegsDriver);
        status |= XMMRegs_Trigger_Leave_TestLoopback_Set(&XMMRegsDriver); // test mode ON + loopback enable
                                                                          // pour GTS_LEAF sur ML507
                                                                          // F. Saillant le 4 septembre 2012
      }
      break;
    default :
      DBG(DBLE, "ERROR : out of range error on GTStype values in function triggerCoreSet\n");
      status |= XST_FAILURE;
      break; 
  }
  
  return status;
}

/************************************************************
triggerSetup --
once the last measurement for the alignment has been done
and the delays corrected for, it opens the MGTs in both directions
and aligns the links
************************************************************/
int triggerSetup(int GTStype, int step)
{
  int status = XST_SUCCESS;
  int usrclk;
  int force_set = DONT_FORCE_SET;
  int block_mode = BLOCKING;
  int iscomma;

  if ( (GTStype != ROOT) && (GTStype != FANIN_FANOUT) && (GTStype != LEAVE) ) {
    DBG(DBLE, "ERROR : out of range on GTStype in function triggerSet");
    return XST_FAILURE; 
  }
  
  /* verifies that the trigger core (either leaf or root) corresponds
  to the GTS type */
  if ( checkCompatibilityTriggerCoreGtsType(GTStype) == XST_FAILURE ) {
    DBG(DBLE, "ERROR : the trigger core is incompatible with the GTS type\n");
    return XST_FAILURE;
  }
  
  DBG(DBLI, "GTS type : ");

  switch (GTStype) {
    case ROOT :
      usrclk = LOCAL_CLK;
      DBG(DBLI, "ROOT\n");
      break;
    case FANIN_FANOUT :
      usrclk = RECOVERED_CLK;
      DBG(DBLI, "FANIN_FANOUT\n");
      break;
    case LEAVE :
      if ( alignModeRead() == CARRIER_INCLUDED )
        usrclk = MICTOR_CLK;
      else
        usrclk = RECOVERED_CLK;
      DBG(DBLI, "LEAF\n");
      break;
    default :
      DBG(DBLE, "ERROR\n");
      return XST_FAILURE;
      break;
  }
  
//  status |= XMMRegs_MuxInOut_TriggerLed_Set(&XMMRegsDriver);

  switch (step) {

    case 1 :

      logAnswer();

      XMMRegs_RocketIO_TriggerRstCarrier_Set(&XMMRegsDriver, 0);
//      XMMRegs_RocketIO_TxDataSel_Unset(&XMMRegsDriver, 0); // disconnect trigger core

      /* one sends comma for the alignment of the backward link */
      status |= mgtDataCommaSet();
  
      status |= muxExtSet(GTStype, USE_MGT, USE_MGT);  
      status |= allRegMuxPathSet();
      status |= clkSet(GTStype, usrclk, USE_MGT, USE_MGT, force_set, block_mode);
  
      break;

    case 2 :

      logAnswer();

      iscomma = COMMA_NOT_DETECTED;
/*
      while (iscomma == COMMA_NOT_DETECTED) {
        iscomma = COMMA_DETECTED;
        if ( XMMRegs_IsTransceiverInGtsTree(&XMMRegsDriver, 0) ) {
          if ( XMMRegs_RocketIO_CommaAlign_Diagnose (&XMMRegsDriver, 0) != COMMA_DETECTED  ) {
            iscomma = COMMA_NOT_DETECTED;
          }
        }
      }
*/
      break;

    case 3 :

      logAnswer();

      XMMRegs_RocketIO_TriggerRstCarrier_Unset(&XMMRegsDriver, 0);
//      XMMRegs_RocketIO_TxDataSel_Set(&XMMRegsDriver, 0); // connect trigger core
      status |= mgtDataCommaUnSet();
      status |= triggerPathSet(GTStype);

      break;
  }

  return status;
}

/************************************************************
triggerStart --
it launches the authorization for the trigger
it launches the trigger using the 
************************************************************/
int triggerStart(int GTStype)
{
  int status = XST_SUCCESS;
  
  if ( (GTStype != ROOT) && (GTStype != FANIN_FANOUT) && (GTStype != LEAVE) ) {
    DBG(DBLE, "ERROR : out of range on GTStype in function triggerStart");
    return XST_FAILURE; 
  }
  DBG(DBLI, "GTS type : ");
  switch (GTStype) {
    case ROOT :
      DBG(DBLI, "ROOT\n");
      break;
    case FANIN_FANOUT :
      DBG(DBLI, "FANIN_FANOUT\n");
      break;
    case LEAVE :
      DBG(DBLI, "LEAF\n");
      break;
    default :
      DBG(DBLE, "ERROR\n");
      break;
  }
  
  status |= triggerCoreSet(GTStype);
  
  return status;
}


/************************************************************
counterRootSetup --
once the last measurement for the alignment has been done
and the delays corrected for, it opens the MGTs in both directions
and aligns the links
************************************************************/
int counterRootSetup(int GTStype)
{
  int status = XST_SUCCESS;
  int usrclk;
  int force_set = DONT_FORCE_SET;
  int block_mode = BLOCKING;
  
  if ( (GTStype != ROOT) && (GTStype != FANIN_FANOUT) && (GTStype != LEAVE) ) {
    DBG(DBLE, "ERROR : out of range on GTStype in function triggerSet");
    return XST_FAILURE; 
  }
  DBG(DBLI, "GTS type : ");
  switch (GTStype) {
    case ROOT :
      usrclk = LOCAL_CLK;
      DBG(DBLI, "ROOT\n");
      break;
    case FANIN_FANOUT :
      usrclk = RECOVERED_CLK;
      DBG(DBLI, "FANIN_FANOUT\n");
      break;
    case LEAVE :
      if ( alignModeRead() == CARRIER_INCLUDED )
        usrclk = MICTOR_CLK;
      else
        usrclk = RECOVERED_CLK;
      DBG(DBLI, "LEAF\n");
      break;
    default :
      DBG(DBLE, "ERROR\n");
      return XST_FAILURE;
      break;
  }
  
  /* one sends comma for the alignment of the backward link */
  status |= mgtDataCommaSet();
  
  status |= muxExtSet(GTStype, USE_MGT, USE_MGT);  
  status |= allRegMuxPathSet();
  status |= clkSet(GTStype, usrclk, USE_MGT, USE_MGT, force_set, block_mode);
  
  return status;
}

/************************************************************
counterRootStart --
it launches the counter from the root node
and reads it at the leaves
It permits to check the coarse and fine alignment of the phase at the leaves
************************************************************/
int counterRootStart(int GTStype)
{
  int status = XST_SUCCESS;
  
  if ( (GTStype != ROOT) && (GTStype != FANIN_FANOUT) && (GTStype != LEAVE) ) {
    DBG(DBLE, "ERROR : out of range on GTStype in function triggerStart");
    return XST_FAILURE; 
  }
  DBG(DBLI, "GTS type : ");
  switch (GTStype) {
    case ROOT :
      DBG(DBLI, "ROOT\n");
      break;
    case FANIN_FANOUT :
      DBG(DBLI, "FANIN_FANOUT\n");
      break;
    case LEAVE :
      DBG(DBLI, "LEAF\n");
      break;
    default :
      DBG(DBLE, "ERROR\n");
      break;
  }
  
  /* one inactivates the commaalign */
  status |= mgtDataCommaUnSet();
  status |= allFifoMuxPathSet(GTStype);
  
  return status;
}

#undef DBG

