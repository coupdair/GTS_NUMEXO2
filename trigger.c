#include "align.h"
#include "xmmregs_i.h"
#include "debug.h"

#define DBG DBG_TRIGGER

int muxClkSyncSet(unsigned int val) {
  return XMMRegs_DataPath_MuxClkSync_Set(&XMMRegsDriver, val);
}

int checkCompatibilityTriggerCoreGtsType(int GTStype) {
  int status = XST_SUCCESS;
  int trigger_type;
  
  trigger_type = XMMRegs_Trigger_CoreType_Get(&XMMRegsDriver);
  
  DBG(DBLD, "trigger_type = %d\n", trigger_type);
  DBG(DBLD, "GTStype = %d\n", GTStype);
  
  switch (trigger_type) {
    case TRIGGER_CORE_IS_ROOT :
      switch (GTStype) {
        case ROOT :
          break;
        case FANIN_FANOUT :
          DBG(DBLW, "WARNING : you use the root trigger core with a fanin-fanout node\n");
          DBG(DBLW, "It is probably an error, except if you know what you are doing\n");
          DBG(DBLW, "It will not be reported as an error\n");
          break;
        default :
          DBG(DBLE, "ERROR : trigger core is ROOT, GTS type is LEAF\n");
          status = XST_FAILURE;
          break; 
      }
      break;
    case TRIGGER_CORE_IS_LEAF :
      switch (GTStype) {
        case LEAVE :
          break;
        case FANIN_FANOUT :
          DBG(DBLE, "ERROR : you use the leaf trigger core with a fanin-fanout node\n");
          status = XST_FAILURE;
          break;
        default :
          DBG(DBLE, "ERROR : trigger core is LEAF, GTS type is ROOT\n");
          status = XST_FAILURE;
          break;
      }
      break;
    case TRIGGER_CORE_IS_FANIN_FANOUT :
      switch (GTStype) {
        case LEAVE :
          DBG(DBLE, "ERROR : trigger core is FANIN_FANOUT, GTS type is LEAF\n");
          status = XST_FAILURE;
          break;
        case FANIN_FANOUT :
          break;
        default :
          DBG(DBLE, "ERROR : trigger core is FANIN_FANOUT, GTS type is ROOT\n");
          status = XST_FAILURE;
          break;
      }
      break;
    default :
      DBG(DBLW, "STRANGE : trigger core is neither root nor leaf nor faninfanout\n");
      status = XST_FAILURE;
      break;  
  }
  
  return status;
}

int triggerPathSet(int GTStype)
{
  int status = XST_SUCCESS;
  
  XMMRegs_DataPath_UseSync_UnSet(&XMMRegsDriver);
  XMMRegs_DataPath_AllRxmux_Set(&XMMRegsDriver, 0); // NUMEXO2
  XMMRegs_DataPath_AllTxmux_Set(&XMMRegsDriver, 1); // NUMEXO2
  
  switch (GTStype) {
    case ROOT :
      break;
    case FANIN_FANOUT :
      break;
    case LEAVE :
      break;
    default :
      DBG(DBLE, "ERROR : out of range error on GTStype values in function triggerPathSet\n");
      status = XST_FAILURE;
      break; 
  }
  
  return status;
}

/* launches the leave trigger core in test-loopback mode 
Applies to a leave GTS */
int leaveTestLoopback(void) {
  return XMMRegs_Trigger_Leave_TestLoopback_Set(&XMMRegsDriver); 
}

/* launches the leave trigger core in loopback mode 
Applies to a leave GTS */
int leaveTest(void) {
  return XMMRegs_Trigger_Leave_Test_Set(&XMMRegsDriver); 
}

int leaveCarrierRequest(void) {
  return XMMRegs_Trigger_Leave_CarrierRequest_Set(&XMMRegsDriver);
}

/* Applies to a root GTS */
int rootLoopback(void) {
  return XMMRegs_Trigger_Root_Loopback_Set(&XMMRegsDriver);
}

int rootAuroraLoopback(void) {
  return XMMRegs_Trigger_Root_AuroraLoopback_Set(&XMMRegsDriver);
}

int daqStart(void) {
  return XMMRegs_Trigger_Daq_Start(&XMMRegsDriver);
}

int daqStop(void) {
  return XMMRegs_Trigger_Daq_Stop(&XMMRegsDriver);
}

int syncPeriodSet(int period_mask) {
  return XMMRegs_Trigger_PeriodMask_Set(&XMMRegsDriver, period_mask);
}

int triggerCoreSet(int GTStype) {
  int status = XST_SUCCESS;
   
  switch (GTStype) {
    case ROOT :
      break;
    case FANIN_FANOUT :
      break;
    case LEAVE :
      if ( XMMRegs_AlignMode_Read(&XMMRegsDriver) == CARRIER_INCLUDED ) {
        DBG(DBLI, "Carrier included - NUMEXO2 : external trigger requests (test mode OFF)\n");
        status |= XMMRegs_Trigger_Leave_CarrierRequest_Set(&XMMRegsDriver);
      }
      else {
//        DBG(DBLI, "Trigger requests are generated by the GTS (test mode ON)\n");
//        status |= XMMRegs_Trigger_Leave_Test_Set(&XMMRegsDriver);
//        status |= XMMRegs_Trigger_Leave_TestLoopback_Set(&XMMRegsDriver);
        DBG(DBLI, "Carrier excluded - NUMEXO2 : external trigger requests (test mode OFF)\n");
        status |= XMMRegs_Trigger_Leave_CarrierRequest_Set(&XMMRegsDriver);
      }
      break;
    default :
      DBG(DBLE, "ERROR : out of range error on GTStype values in function triggerCoreSet\n");
      status |= XST_FAILURE;
      break; 
  }
  
  return status;
}

/************************************************************
triggerSetup --
once the last measurement for the alignment has been done
and the delays corrected for, it opens the MGTs in both directions
and aligns the links
************************************************************/
int triggerSetup(int GTStype, int step)
{
  int status = XST_SUCCESS;
  int usrclk;
  int iscomma;

  if ( (GTStype != ROOT) && (GTStype != FANIN_FANOUT) && (GTStype != LEAVE) ) {
    DBG(DBLE, "ERROR : out of range on GTStype in function triggerSet");
    return XST_FAILURE; 
  }
  
  /* verifies that the trigger core (either leaf or root) corresponds
  to the GTS type */
  if ( checkCompatibilityTriggerCoreGtsType(GTStype) == XST_FAILURE ) {
    DBG(DBLE, "ERROR : the trigger core is incompatible with the GTS type\n");
    return XST_FAILURE;
  }
  
  DBG(DBLI, "GTS type : ");

  switch (GTStype) {
    case ROOT :
      usrclk = LOCAL_CLK;
      DBG(DBLI, "ROOT\n");
      break;
    case FANIN_FANOUT :
      usrclk = RECOVERED_CLK;
      DBG(DBLI, "FANIN_FANOUT\n");
      break;
    case LEAVE :
      if ( alignModeRead() == CARRIER_INCLUDED )
        usrclk = MICTOR_CLK;
      else
        usrclk = RECOVERED_CLK;
      DBG(DBLI, "LEAF\n");
      break;
    default :
      DBG(DBLE, "ERROR\n");
      return XST_FAILURE;
      break;
  }
  
  switch (step) {

    case 1 :

      logAnswer();

      XMMRegs_RocketIO_TriggerRstCarrier_Set(&XMMRegsDriver);

      /* one sends comma for the alignment */
      mgtDataCommaSet();
  
      status  = muxExtSet(GTStype, USE_MGT, USE_MGT);  
      status |= allRegMuxPathSet();
      status |= clkSet(GTStype, usrclk, USE_MGT, USE_MGT, DONT_FORCE_SET, BLOCKING);
  
      break;

    case 2 :

      logAnswer();

      iscomma = COMMA_NOT_DETECTED;
/*
      while (iscomma == COMMA_NOT_DETECTED) {
        iscomma = COMMA_DETECTED;
        if ( XMMRegs_IsTransceiverInGtsTree(&XMMRegsDriver, 0) ) {
          if ( XMMRegs_RocketIO_CommaAlign_Diagnose (&XMMRegsDriver, 0) != COMMA_DETECTED  ) {
            iscomma = COMMA_NOT_DETECTED;
          }
        }
      }
*/
      break;

    case 3 :

      logAnswer();

      XMMRegs_RocketIO_TriggerRstCarrier_Unset(&XMMRegsDriver);

      mgtDataCommaUnSet();
      status = triggerPathSet(GTStype);

      break;
  }

  return status;
}

/************************************************************
triggerStart --
it launches the authorization for the trigger
it launches the trigger using the 
************************************************************/
int triggerStart(int GTStype)
{
  if ( (GTStype != ROOT) && (GTStype != FANIN_FANOUT) && (GTStype != LEAVE) ) {
    DBG(DBLE, "ERROR : out of range on GTStype in function triggerStart");
    return XST_FAILURE; 
  }

  DBG(DBLI, "GTS type : ");
  switch (GTStype) {
    case ROOT :
      DBG(DBLI, "ROOT\n");
      break;
    case FANIN_FANOUT :
      DBG(DBLI, "FANIN_FANOUT\n");
      break;
    case LEAVE :
      DBG(DBLI, "LEAF\n");
      break;
    default :
      DBG(DBLE, "ERROR\n");
      break;
  }
  
  return triggerCoreSet(GTStype);
}

/************************************************************
coreTriggerStop/Start --
it resets / starts the trigger core 
************************************************************/
int triggerCoreStop(void)
{
  int status = XST_SUCCESS;
  status |= XMMRegs_Trigger_CoreStop(&XMMRegsDriver);
  return status; 
}

int triggerCoreStart(void)
{
  int status = XST_SUCCESS;
  status |= XMMRegs_Trigger_CoreStart(&XMMRegsDriver);
  return status; 
}

unsigned long triggerCoreReset(void)
{
  int status = XST_SUCCESS;
  status |= XMMRegs_Trigger_CoreStop(&XMMRegsDriver);
  status |= XMMRegs_Trigger_CoreStart(&XMMRegsDriver);
  return status; 
}

/************************************************************
counterRootSetup --
once the last measurement for the alignment has been done
and the delays corrected for, it opens the MGTs in both directions
and aligns the links
************************************************************/
int counterRootSetup(int GTStype)
{
  int status = XST_SUCCESS;
  int usrclk;

  if ( (GTStype != ROOT) && (GTStype != FANIN_FANOUT) && (GTStype != LEAVE) ) {
    DBG(DBLE, "ERROR : out of range on GTStype in function triggerSet");
    return XST_FAILURE; 
  }
  DBG(DBLI, "GTS type : ");
  switch (GTStype) {
    case ROOT :
      usrclk = LOCAL_CLK;
      DBG(DBLI, "ROOT\n");
      break;
    case FANIN_FANOUT :
      usrclk = RECOVERED_CLK;
      DBG(DBLI, "FANIN_FANOUT\n");
      break;
    case LEAVE :
      if ( alignModeRead() == CARRIER_INCLUDED )
        usrclk = MICTOR_CLK;
      else
        usrclk = RECOVERED_CLK;
      DBG(DBLI, "LEAF\n");
      break;
    default :
      DBG(DBLE, "ERROR\n");
      return XST_FAILURE;
      break;
  }
  
  /* one sends comma for the alignment of the backward link */
  mgtDataCommaSet();
  
  status  = muxExtSet(GTStype, USE_MGT, USE_MGT);  
  status |= allRegMuxPathSet();
  status |= clkSet(GTStype, usrclk, USE_MGT, USE_MGT, DONT_FORCE_SET, BLOCKING);
  
  return status;
}

/************************************************************
counterRootStart --
it launches the counter from the root node
and reads it at the leaves
It permits to check the coarse and fine alignment of the phase at the leaves
************************************************************/
int counterRootStart(int GTStype)
{
  int status = XST_SUCCESS;
  
  if ( (GTStype != ROOT) && (GTStype != FANIN_FANOUT) && (GTStype != LEAVE) ) {
    DBG(DBLE, "ERROR : out of range on GTStype in function triggerStart");
    return XST_FAILURE; 
  }
  DBG(DBLI, "GTS type : ");
  switch (GTStype) {
    case ROOT :
      DBG(DBLI, "ROOT\n");
      break;
    case FANIN_FANOUT :
      DBG(DBLI, "FANIN_FANOUT\n");
      break;
    case LEAVE :
      DBG(DBLI, "LEAF\n");
      break;
    default :
      DBG(DBLE, "ERROR\n");
      break;
  }
  
  /* one inactivates the commaalign */
  mgtDataCommaUnSet();
  status = allFifoMuxPathSet(GTStype);
  
  return status;
}

#undef DBG

